m_sol_aux <- cuenta_asignaciones(m_sol_aux,mat_asig)
}#Fin if(num_gpos>0)
}#Fin for(h)
}
mat_asignacion <- mat_asignacion %>% filter(Materia != 0)
cat("\nLa matriz mat_esqueleto tiene: ", sum(mat_esqueleto)," grupos" )
cat("\nSe generaron: ", sum(mat_esqueleto) - sum(m_esq_aux),
" grupos en la asignación" )
cat("\nLa función gen_asignacion tomó: ", (proc.time()-ptm)[3],
" segundos\n\n\n" )
View(mat_asignacion)
param$vec_nom_materias_total
mat_asignacion <- data.frame(Materia = 0, Profesor = 0,TC = 0,
Horario = 0)
Materias <- param$vec_nom_materias_total
Num_Asig <- rep(0,dim(mat_solicitudes_real)[1])
m_sol_aux <- cbind(mat_solicitudes_real,Num_Asig)#Con el # de asig. de cada prof.
m_esq_aux <- mat_esqueleto
m
m <- 1
materia <- Materias[m]
cat("\nMateria ",m,": ",materia)
(vec_aux_esq <- mat_esqueleto[,m])
for(h in 1:length(param$Horas)){
mat_aux_solicitud <- m_sol_aux %>% filter(Materia == materia)
(num_gpos <- vec_aux_esq[h])
if(num_gpos > 0){#Si el # de gpos. simulados > 0
#' La matriz "m_aux" tiene las solicitudes de los profesores
#' que aún no pasan el número máximo de asignaciones.
m_aux <- mat_aux_solicitud%>% filter(
as.numeric(Num_Asig)<param$num_max_asig) %>% filter(
Horario==param$Horas[h])
if(dim(m_aux)[1] > num_gpos){
#'En caso de que se tengan más grupos de los simulados en
#'el esqueleto
mat_asig <- m_aux[sample(1:dim(m_aux)[1],size = num_gpos),
c(3,1,2,5)]
mat_asignacion <- rbind(mat_asignacion,mat_asig)
m_esq_aux[h,m] <- m_esq_aux[h,m] - num_gpos
}else{
mat_asig <- m_aux[,c(3,1,2,5)]
mat_asignacion <- rbind(mat_asignacion,mat_asig)
m_esq_aux[h,m] <- m_esq_aux[h,m] - dim(m_aux)[1]
}
m_sol_aux <- cuenta_asignaciones(m_sol_aux,mat_asig)
}#Fin if(num_gpos>0)
}#Fin for(h)
mat_asignacion
View(mat_solicitudes_real)
View(mat_esqueleto)
#' 4b) Simulación de solicitudes de profesores (pseudo-real)
set.seed(1806)
mat_solicitudes_real <- gen_solicitudes_real(mat_esqueleto,param)#8.3 seg
#Se definen las variables que se van a utilizar
(tam_poblacion <- param$tam_poblacion)
(num_generaciones <- param$num_generaciones)
prob_mutacion <- param$prob_mutacion
n_cols_mat_calif <- param$n_cols_mat_calif
matrices_calif_x_generacion <- list()
mejores_asig <- list()
vec_prob_asig <- (2*(1:tam_poblacion))/(tam_poblacion*(tam_poblacion+1))
calif_mejor_elem <- rep(0,(num_generaciones+1))
colMain <- colorRampPalette(brewer.pal(8, "Blues"))(25)
mat_calif_generaciones <- matrix(0,nrow = tam_poblacion,
ncol = (num_generaciones+1))
mat_num_genes <- matrix(0,nrow = tam_poblacion,
ncol = (num_generaciones+1))
mat_solicitudes_restantes <- mat_solicitudes_real#1886 5
ptm_generaciones <- proc.time()# Start the clock!
# g <- 1
# g <- 2
for(g in 1:num_generaciones){
cat("\n *** GENERACIÓN ",g," ***")
# ptm <- proc.time()# Start the clock!
if(g == 1){#Población inicial
### 1) Generar población inicial y 2) Calificar
lista_info_inicial <- poblacion_calif_iniciales(mat_esqueleto,
mat_solicitudes_real,
param)#5.22/4.82 min
mat_calif_asig <- lista_info_inicial[[1]]
# pob_ini <- lista_info_inicial[[2]]
poblacion <- lista_info_inicial[[2]]
for (p in 1:tam_poblacion) {
mat_num_genes[p,g] <- dim(poblacion[[p]])[1]
}
### 12) Guardar una matriz con la calificación x gpo. de las
#' asignaciones (como xiii de T45)
matrices_calif_x_generacion[[g]] <- lista_info_inicial[[3]]
### 13) Hacer heatmap de la matriz en 12)
heatmap(matrices_calif_x_generacion[[g]][,1:650],
Colv = NA, Rowv = NA,
main = paste0("Calificaciones ordenadas de generación ",g),
scale="none",col=colMain)
### 11) Guardar la mejor asignación de la generación
ind_mejor_asig <- mat_calif_asig[tam_poblacion,1]
mejores_asig[[g]] <- list(mat_calif_asig,
poblacion[[ind_mejor_asig]])
#Graficar datos
calif_mejor_elem[g] <- mat_calif_asig[tam_poblacion,2]
plot(calif_mejor_elem[1:g],main = "Calificaciones del mejor elemento",
xlab = "Generación",ylab = "Calificación")
mat_calif_generaciones[,g] <- mat_calif_asig[,2]
matplot(mat_calif_generaciones[,1:g],type = "l",
main = "Calificaciones de las asignaciones por generación",
xlab = "Asignaciones",ylab = "Calificaciones")
matplot(mat_num_genes[,1:g],type = "l",
main = "Número de genes por generación",
xlab = "Asignaciones",ylab = "Número de genes")
}#Termina población inicial
# ### 13) Hacer heatmap de la matriz en 12)
# heatmap(matrices_calif_x_generacion[[g]][,1:650],
#         Colv = NA, Rowv = NA,
#         main = paste0("Calificaciones ordenadas de generación ",g),
#         scale="none",col=colMain)
#
# ### 11) Guardar la mejor asignación de la generación
# ind_mejor_asig <- mat_calif_asig[tam_poblacion,1]
# mejores_asig[[g]] <- list(mat_calif_asig,
#                           poblacion[[ind_mejor_asig]])
#
# #Graficar datos
# calif_mejor_elem[g] <- mat_calif_asig[tam_poblacion,2]
# plot(calif_mejor_elem[1:g],main = "Calificaciones del mejor elemento",
#      xlab = "Generación",ylab = "Calificación")
# mat_calif_generaciones[,g] <- mat_calif_asig[,2]
# matplot(mat_calif_generaciones[,1:g],type = "l",
#         main = "Calificaciones de las asignaciones por generación",
#         xlab = "Asignaciones",ylab = "Calificaciones")
# save(calif_mejor_elem,file = "calif_mejor_elem.RData")
# save(mat_calif_generaciones,file = "mat_calif_generaciones.RData")
# ptm_pob <- proc.time()# Start the clock!
for(n in 1:tam_poblacion){
cat("\n *** HIJO ",n," ***")
if(n == 1){poblacion_nueva <- list()}
hijo <- data.frame(Materia = 0, Profesor = 0,TC = 0,
Horario = 0)
esq_hijo <- matrix(0,nrow = length(param$Horas),
ncol = length(param$vec_nom_materias_total))
### 4) Elegir 2 padres con prob = 2i/(n*(n+1))
#' La selección es por "Rank Selection":
#' a) Elegir 2 individuos aleatoriamente
#' b) La asignación con la calificación más alta es el padre 1
#' c) Repetir a) y b) para el padre 2
#' Nota: Se toman los índices y no los números de las asignaciones
#' porque se tiene el vector de probabilidades que depende de
#' la posición en la que se encuentren las asignaciones.
ind_padres <- c(0,0)
(ind_mat_1 <- sample(x = 1:tam_poblacion,size = 2,
prob = vec_prob_asig))
(ind_padres[1] <- max(ind_mat_1))
(ind_mat_2 <- sample(x = 1:tam_poblacion,size = 2,
prob = vec_prob_asig))
#' Para no tener al mismo padre dos veces
while(max(ind_mat_2) == max(ind_mat_1)){
(ind_mat_2 <- sample(x = 1:tam_poblacion,size = 2,
prob = vec_prob_asig))
# cat("\n max(ind_mat_1) = ",max(ind_mat_1))
# cat("\n max(ind_mat_2) = ",max(ind_mat_2))
}
(ind_padres[2] <- max(ind_mat_2))
padre_1 <- poblacion[[ind_padres[1]]]
padre_2 <- poblacion[[ind_padres[2]]]
# write.csv(poblacion[[ind_padres[1]]], file = "padre_1.csv")
# write.csv(poblacion[[ind_padres[2]]], file = "padre_2.csv")
while(dim(padre_1)[1]!=0 && dim(padre_2)[1]!=0){
# Repetir hasta que uno de los padres se quede sin genes.
### 5) Con prob = 0.5 se elige un padre
(ind_padre_elegido <- sample(x=1:2,size = 1))
cat("\n Se eligió al padre ",ind_padre_elegido)
# cat(paste("Se eligió al padre ",ind_padre_elegido),
#     file="outfile.txt",sep="\n",append=TRUE)
if(ind_padre_elegido == 1){
padre_elegido <- padre_1
}else{
padre_elegido <- padre_2
}
### 6) Elegir un gen (grupo) del padre seleccionado con prob = 2i/(n*(n+1))
(num_genes <- dim(padre_elegido)[1])
vec_prob_genes <- (2*(1:num_genes))/(num_genes*(num_genes+1))
(ind_gen <- sample(x = 1:num_genes,
size = 1,
prob = vec_prob_genes))
(gen_elegido <- padre_elegido[ind_gen,1:4])
### 7) Mutación
(r_num_muta <- runif(1))
if(r_num_muta<prob_mutacion && dim(mat_solicitudes_restantes)[1]>0){
#La 2° condición verifica si aún hay solicitudes para elegir
cat("\n Entra a mutación")
cat("\n dim(mat_solicitudes_restantes)[1] = ",
dim(mat_solicitudes_restantes)[1])
# cat("Entra a mutación",file="outfile.txt",sep="\n",append=TRUE)
(gen_elegido <- elige_gen_de_solicitud(mat_solicitudes_restantes,
hijo,param))
}
if(r_num_muta<prob_mutacion && dim(mat_solicitudes_restantes)[1]==0){
#La 2° condición verifica que ya no hay solicitudes para elegir
cat("\n*** La matriz mat_solicitudes_restantes, ya no tiene información ***")
cat("\n*** g = ",g," ***")
cat("\n*** hijo = ",n," ***")
}
if(dim(gen_elegido)[1]==0 || is.na(gen_elegido[1])){
#' Cuando la matriz de solicitudes restantes tiene pocos
#' grupos se arroja un gen lleno de NA's
cat("\n Entra al if de *emergencia*")
(gen_elegido <- padre_elegido[ind_gen,1:4])
}
hijo <- rbind(hijo,gen_elegido)
(num_materia_gen <- arroja_num_materia(as.character(gen_elegido[1])))
(ind_hora_gen <- which(7:21 == as.numeric(gen_elegido[4])))
esq_hijo[ind_hora_gen,num_materia_gen] <- esq_hijo[ind_hora_gen,
num_materia_gen] + 1
#' Se ajusta la información de las solicitudes
mat_solicitudes_restantes <- ajusta_mat_solicitudes(
mat_solicitudes_restantes,gen_elegido)
### 8) Ajustar información de los padres con respecto al nuevo
###gen del hijo
# (num_materia_gen <- arroja_num_materia(as.character(gen_elegido[1])))
# num_max_gpos[2,num_materia_gen] <- num_max_gpos[2,num_materia_gen] + 1
lista_padres <- ajusta_genes_padres(esq_hijo,padre_1,padre_2,
gen_elegido,mat_esqueleto)
# lista_padres <- ajusta_genes_padres(esq_hijo,padre_1,padre_2,
#                                     gen_elegido,mat_esqueleto_cotas)
padre_1 <- lista_padres[[1]]
padre_2 <- lista_padres[[2]]
}#Fin while()
#' Quitamos el renglón de ceros inicial
hijo <- unique(hijo)#Para evitar repeticiones en los grupos
hijo <- hijo %>% filter(Profesor != 0)
### 9) Añadir los genes restantes del otro padre al hijo
if(dim(padre_1)[1] > 0){
for(i in 1:dim(padre_1)[1]){
gen_elegido <- padre_1[i,]
(num_materia_gen <- arroja_num_materia(as.character(gen_elegido[1])))
(ind_hora_gen <- which(7:21 == as.numeric(gen_elegido[4])))
esq_hijo[ind_hora_gen,num_materia_gen] <- esq_hijo[ind_hora_gen,
num_materia_gen]+1
}
hijo <- rbind(hijo,padre_1[,1:4])
}
if(dim(padre_2)[1] > 0){
for(i in 1:dim(padre_2)[1]){
gen_elegido <- padre_2[i,]
(num_materia_gen <- arroja_num_materia(as.character(gen_elegido[1])))
(ind_hora_gen <- which(7:21 == as.numeric(gen_elegido[4])))
esq_hijo[ind_hora_gen,num_materia_gen] <- esq_hijo[ind_hora_gen,
num_materia_gen]+1
}
hijo <- rbind(hijo,padre_2[,1:4])
}
#' Se asignan profesores a los grupos faltantes, como la
#' población inicial.
esq_gpos_faltantes <- mat_esqueleto - esq_hijo
lista_asig <- gen_asignacion(esq_gpos_faltantes,
mat_solicitudes_restantes,
param)#12.78 seg
mat_asig <- lista_asig[[1]]
hijo <- rbind(hijo,mat_asig)
### 2) Calificar y 3) Ordenar las calificaciones del hijo
# esq_hijo <- gen_esq_hijo(hijo,param)#Grupos con profesor en el hijo
lista_hijo <- list(hijo,esq_hijo)
lista_calif_hijo <- califica_asignacion(mat_esqueleto,
mat_solicitudes_real,
lista_hijo,param)
poblacion_nueva[[n]] <- lista_calif_hijo
#Cada hijo vuelve a iniciar con la matriz de solicitudes completa
mat_solicitudes_restantes <- mat_solicitudes_real#1886 5
}#Fin for(n)
# cat("\nEl ciclo tardó: ",(proc.time()-ptm_pob)[3]/60,
#     " minutos. Para 1 generación \n")#15/37.83min
lista_info <- califica_ordena_asig(poblacion_nueva,param)
mat_calif_asig <- lista_info[[1]]
poblacion <- lista_info[[2]]
for (p in 1:tam_poblacion) {
mat_num_genes[p,(g+1)] <- dim(poblacion[[p]])[1]
}
# save(mat_num_genes,file = "mat_num_genes.RData")
### 12) Guardar una matriz con la calificación x gpo. de las
#' asignaciones (como xiii de T45)
matrices_calif_x_generacion[[(g+1)]] <- lista_info[[3]]
### 13) Hacer heatmap de la matriz en 12)
heatmap(matrices_calif_x_generacion[[(g+1)]][,1:650],
Colv = NA, Rowv = NA,
main = paste0("Calificaciones ordenadas de generación ",g+1),
scale="none",col=colMain)
### 11) Guardar la mejor asignación de la generación
ind_mejor_asig <- mat_calif_asig[tam_poblacion,1]
mejores_asig[[(g+1)]] <- list(mat_calif_asig,
poblacion[[ind_mejor_asig]])
#Graficar datos
calif_mejor_elem[(g+1)] <- mat_calif_asig[tam_poblacion,2]
plot(calif_mejor_elem[1:(g+1)],
main = "Calificaciones del mejor elemento",
xlab = "Generación",ylab = "Calificación")
mat_calif_generaciones[,(g+1)] <- mat_calif_asig[,2]
matplot(mat_calif_generaciones[,1:(g+1)],type = "l",
main = "Calificaciones de las asignaciones por generación",
xlab = "Asignaciones",ylab = "Calificaciones")
matplot(mat_num_genes[,1:(g+1)],type = "l",
main = "Número de genes por generación",
xlab = "Asignaciones",ylab = "Número de genes")
}#Fin for(g)
cat("\nEl ciclo tardó: ",(proc.time()-ptm_generaciones)[3]/60,
" minutos. Para ",num_generaciones," generaciones \n")
153.95/60
### 14) Se define la asignación final
mejor_asig <- mejores_asig[[(num_generaciones+1)]][[2]]
mat_asignacion_final <- cbind(mejor_asig$Materia,
mejor_asig$Profesor,
mejor_asig$Horario)
colnames(mat_asignacion_final) <- c("Materia","Profesor","Horario")
# mat_esqueleto asignación final ------------------------------------------
esq_asig_final <- matrix(0,nrow = length(param$Horas),
ncol = length(param$vec_nom_materias_total))
rownames(esq_asig_final) <- param$nombre_hrs
colnames(esq_asig_final) <- param$vec_nom_materias_total
asig_final  <- data.frame(mat_asignacion_final ,Num_Materia = 0)
for(r in 1:dim(asig_final )[1]){
materia <- asig_final$Materia[r]
asig_final$Num_Materia[r] <- arroja_num_materia(materia)
}
for(m in 1:length(param$vec_nom_materias_total)){
materia <- param$vec_nom_materias_total[m]
cat("\n Materia ",m,": ",materia)
mat_materia <- asig_final  %>% filter(Materia == materia)
for(h in 1:length(param$Horas)){
hora <- param$Horas[h]
mat_hora <- mat_materia %>% filter(Horario == hora)
esq_asig_final[h,m] <- dim(mat_hora)[1]
}
}
# Info de grupos sin asignación -------------------------------------------
dif_x_materia <- colSums(mat_esqueleto) - colSums(esq_asig_final)
dif_rel <- (colSums(mat_esqueleto) - colSums(esq_asig_final))/colSums(mat_esqueleto)
info_gpos_sin_asig <- data.frame(mat_esq = colSums(mat_esqueleto),
esq_asig_fin = colSums(esq_asig_final),
gpos_sin_asig = dif_x_materia,
dif_rel = dif_rel)
mat_info_AG
# dim(mat_info_AG)
num_prueba <- 5
mat_info_AG[num_prueba,3] <- 153.95#min
mat_info_AG[num_prueba,4] <- max(calif_mejor_elem)
mat_info_AG[num_prueba,5] <- dim(mat_asignacion_final)[1]
mat_info_AG[num_prueba,6] <- calif_mejor_elem[num_generaciones+1]
mat_info_AG[num_prueba,7] <- mean(mat_num_genes[,1])
mat_info_AG[num_prueba,8] <- mean(mat_num_genes[,2:(num_generaciones+1)])
mat_info_AG
# Lista 5.1 ---------------------------------------------------------------
dat_sem_20202_g10_n05_m004_U514 <- list()
dat_sem_20202_g10_n05_m004_U514[[1]] <- mat_asignacion_final
dat_sem_20202_g10_n05_m004_U514[[2]] <- calif_mejor_elem #Vector con calificaciones de los mejores elementos por generación
dat_sem_20202_g10_n05_m004_U514[[3]] <- mat_calif_generaciones #Matriz con calificaciones de todos los elementos de todas las generaciones
dat_sem_20202_g10_n05_m004_U514[[4]] <- matrices_calif_x_generacion #Lista de tamaño num_generaciones+1 con las matrices de calificaciones ordenadas por generación .
dat_sem_20202_g10_n05_m004_U514[[5]] <- mejores_asig #Lista de tamaño num_generaciones+1 con la información de los mejores hijos de cada generación.
dat_sem_20202_g10_n05_m004_U514[[6]] <- mat_num_genes #Matriz con el número de genes de todos los elementos por generación
dat_sem_20202_g10_n05_m004_U514[[7]] <- mat_esqueleto
dat_sem_20202_g10_n05_m004_U514[[8]] <- mat_solicitudes_real
dat_sem_20202_g10_n05_m004_U514[[9]] <- param
dat_sem_20202_g10_n05_m004_U514[[10]] <- mat_info_AG #Tabla con información del AG y sus resultados
dat_sem_20202_g10_n05_m004_U514[[11]] <- esq_asig_final #mat_esqueleto de la asignación final
dat_sem_20202_g10_n05_m004_U514[[12]] <- info_gpos_sin_asig #Matriz con las columnas: mat_esq (gpos. x materia en mat_esqueleto), esq_asig_fin (gpos. x materia en esq_asig_final), gpos_sin_asig (gpos. sin asignación x materia), dif_rel (diferencia relativa x materia)
names(dat_sem_20202_g10_n05_m004_U514) <- c("mat_asignacion_final",
"calif_mejor_elem",
"mat_calif_generaciones",
"matrices_calif_x_generacion",
"mejores_asig",
"mat_num_genes",
"mat_esqueleto",
"mat_solicitudes_real",
"param",
"mat_info_AG",
"esq_asig_final",
"info_gpos_sin_asig")
save(dat_sem_20202_g10_n05_m004_U514,file = "dat_sem_20202_g10_n05_m004_U-514.RData")
plot(calif_mejor_elem,main = "Calificaciones del mejor elemento",
xlab = "Generación",ylab = "Calificación")
# Figura: Media calificaciones --------------------------------------------
(media_x_generacion <- colMeans(mat_calif_generaciones))
plot(media_x_generacion,main = "Promedio de calificaciones por generación",
xlab = "Generación",ylab = "Media de calificación")
(var_x_generacion <- colVars(mat_calif_generaciones))
plot(var_x_generacion,main = "Varianza de calificaciones por generación",
xlab = "Generación",ylab = "Varianza de calificación")
# Figura: Boxplot calificaciones ------------------------------------------
#Definimos el data.frame que necesitamos para graficar los boxplots
df_calif_gen <- data.frame(Calificaciones = 0,
Generaciones = sort(rep(c(1:dim(mat_calif_generaciones)[2]),
dim(mat_calif_generaciones)[1])))
for(k in 1:dim(mat_calif_generaciones)[2]){
vec <- (10*(k-1))+1:10
# cat("\nk = ", k,"\n\n vec = ",vec)
df_calif_gen[vec,1] <- mat_calif_generaciones[,k]
}
# Create basic boxplot
ggboxplot(df_calif_gen, x = "Generaciones",xlab = "Generación",
main = "                            Calificación de asignaciones por generación",
y = "Calificaciones",ylab = "Calificación",
add = "jitter")
mat_calif_generaciones
df_calif_gen
dim(mat_calif_generaciones)
# Figura: Boxplot calificaciones ------------------------------------------
#Definimos el data.frame que necesitamos para graficar los boxplots
df_calif_gen <- data.frame(Calificaciones = 0,
Generaciones = sort(rep(c(1:dim(mat_calif_generaciones)[2]),
dim(mat_calif_generaciones)[1])))
df_calif_gen
dim(mat_calif_generaciones)
k
(10*(k-1))+1:10
(10*(k-1))+1:dim(mat_calif_generaciones)[1]
(dim(mat_calif_generaciones)[1]*(k-1))+1:dim(mat_calif_generaciones)[1]
# Figura: Boxplot calificaciones ------------------------------------------
#Definimos el data.frame que necesitamos para graficar los boxplots
df_calif_gen <- data.frame(Calificaciones = 0,
Generaciones = sort(rep(c(1:dim(mat_calif_generaciones)[2]),
dim(mat_calif_generaciones)[1])))
for(k in 1:dim(mat_calif_generaciones)[2]){
vec <- (dim(mat_calif_generaciones)[1]*(k-1))+1:dim(mat_calif_generaciones)[1]
# cat("\nk = ", k,"\n\n vec = ",vec)
df_calif_gen[vec,1] <- mat_calif_generaciones[,k]
}
# Create basic boxplot
ggboxplot(df_calif_gen, x = "Generaciones",xlab = "Generación",
main = "                            Calificación de asignaciones por generación",
y = "Calificaciones",ylab = "Calificación",
add = "jitter")
plot(calif_mejor_elem,main = "Calificaciones del mejor elemento",
xlab = "Generación",ylab = "Calificación")
# Figura: Media calificaciones --------------------------------------------
(media_x_generacion <- colMeans(mat_calif_generaciones))
plot(media_x_generacion,main = "Promedio de calificaciones por generación",
xlab = "Generación",ylab = "Media de calificación")
(var_x_generacion <- colVars(mat_calif_generaciones))
plot(var_x_generacion,main = "Varianza de calificaciones por generación",
xlab = "Generación",ylab = "Varianza de calificación")
# Figura: Boxplot calificaciones ------------------------------------------
#Definimos el data.frame que necesitamos para graficar los boxplots
df_calif_gen <- data.frame(Calificaciones = 0,
Generaciones = sort(rep(c(1:dim(mat_calif_generaciones)[2]),
dim(mat_calif_generaciones)[1])))
for(k in 1:dim(mat_calif_generaciones)[2]){
vec <- (dim(mat_calif_generaciones)[1]*(k-1))+1:dim(mat_calif_generaciones)[1]
# cat("\nk = ", k,"\n\n vec = ",vec)
df_calif_gen[vec,1] <- mat_calif_generaciones[,k]
}
# Create basic boxplot
ggboxplot(df_calif_gen, x = "Generaciones",xlab = "Generación",
main = "                            Calificación de asignaciones por generación",
y = "Calificaciones",ylab = "Calificación",
add = "jitter")
# Figura: Boxplot número de genes -----------------------------------------
#Definimos el data.frame que necesitamos para graficar los boxplots
df_num_gen <- data.frame(Num_genes = 0,
Generaciones = sort(rep(c(1:dim(mat_num_genes)[2]),
dim(mat_num_genes)[1])))
k
(dim(mat_num_genes)[1]*(k-1))+1:dim(mat_num_genes)[1]
for(k in 1:dim(mat_num_genes)[2]){
vec <- (dim(mat_num_genes)[1]*(k-1))+1:dim(mat_num_genes)[1]
# cat("\nk = ", k,"\n\n vec = ",vec)
df_num_gen[vec,1] <- mat_num_genes[,k]
}
# Create basic boxplot
ggboxplot(df_num_gen, x = "Generaciones",xlab = "Generación",
main = "                  Número de genes en asignaciones por generación",
y = "Num_genes",ylab = "Número de genes",
add = "jitter")
mat_info_AG
View(mat_info_AG)
View(mat_info_AG)
load("mat_def_grupos_simulados.RData")
dim_mat <- dim(mat_def_grupos_simulados)
dim_mat
nombre_col <- "Materia"
nombre_col
mat_def_grupos_simulados
View(mat_def_grupos_simulados)
vec <-
for(d in 1:dim_mat[1]){
if(nombre_col == mat_def_grupos_simulados[d,1]){
num_col <- mat_def_grupos_simulados[d,2]
}
}
(num_col <- as.numeric(num_col))
vec <- mat_def_grupos_simulados[,1]
View(mat_solicitudes_real)
View(mat_asignacion_final)
View(info_gpos_sin_asig)
View(mat_esqueleto)
arroja_num_materia("Topología III")#174
arroja_num_materia("Procesos Estocásticos II")
arroja_num_materia("Cálculo Diferencial e Integral II")#48
arroja_num_materia("Economía")#84
arroja_num_materia("Inglés III")#174
arroja_num_materia("Topología III")#102
arroja_num_materia("Matemáticas Actuariales del Seguro de Personas II")#80
arroja_num_materia("Lógica Matemática I")#102
arroja_num_materia("Matemáticas Actuariales del Seguro de Personas I")#80
arroja_num_materia("Matemáticas Actuariales para Seguro de Daños, Fianzas y Reaseguro")#80
arroja_num_materia("Administración Actuarial del Riesgo")#61
arroja_num_materia("Seminario de Estadística I")
arroja_num_materia("Teoría del Seguro")
arroja_num_materia("Seminario de Apoyo a la Titulación en Matemáticas")#1
arroja_num_materia("Mecánica Analítica")#187
arroja_num_materia("Seminario de Geometría A")#13
arroja_num_materia("Inglés VI")#174
arroja_num_materia("Álgebra Moderna I")
arroja_num_materia("Seminario de Topología A")#70
arroja_num_materia("Análisis Matemático III")#34
arroja_num_materia("Estructuras Discretas")#40
arroja_num_materia("Cálculo Diferencial e Integral III")#48
