#' (materias). En la entrada (i,j) se tiene el número de grupos simulados
#' para la hora i, y la materia j.
#' @param mat_solicitudes_real: Matriz de 5 columnas (Profesor,TC,Materia,
#' Num_Materia,Horario) que tiene la información de la solicitud de los
#' profesores. Se hace una "intersección" con los grupos simulados en la
#' matriz "mat_esqueleto" y así se obtienen las solicitudes pseudo-reales
#' de los profesores.
#' @param lista_asignacion: Lista de 3 elementos:
#' 1) mat_asignacion: Matriz de cuatro columnas (Materia, Profesor,
#' TC,Horario) la cual contiene en el i-ésimo renglón la asignación
#' por materia, profesor y horario. La columna TC indica si el profesor
#' es o no de tiempo completo.
#' 2) m_esq_aux: Matriz con el número de grupos en cada hijo.
#' 3) m_sol_aux: Matriz de solicitudes reales con el número de materias
#' asignadas por profesor. (NO SE UTILIZA, SE PUEDE BORRAR DE LA LISTA)
#' @param param: Lista con los diferentes parámetros que se utilizan en las
#' funciones que se mandan llamar.
#' @example param <- list(nombre_hrs = c("7-8","8-9"),nombre_sem = c("2015-1",
#' "2015-2"),Semestres = c(20192,20201),Horas = c(7,8,9,10),q1 = 80, q2 = 90)
#'
#' @return lista_calif_asignacion: Lista con 2 elementos:
#' 1) mat_calif_asig_x_gpo: Matriz de 6 columnas (Materia,Profesor,TC,
#' Horario, calif, Prob_Ac), que contiene la información por grupo asignado.
#' 2) calif_asignacion: Variable tipo numeric que indica la calificación
#' global de la asignación.
#'
#' @examples
#' lista_calif_asignacion <- califica_asignacion(mat_esqueleto,
#' mat_solicitudes_real,lista_asignacion,param)
#'
califica_asignacion <- function(mat_esqueleto,mat_solicitudes_real,
lista_asignacion,param){
ptm <- proc.time()# Start the clock!
#Se definen las variables que se van a utilizar
mat_asignacion <- lista_asignacion[[1]]
mat_esqueleto_aux <- lista_asignacion[[2]]
mat_calif_asig_x_gpo <- data.frame(mat_asignacion,calif = 0, Prob_Ac = 0)
#' Penalización por grupo en esqueleto sin profesor:
#' Se resta de acuerdo a la diferencia relativa por grupo sin profesor.
mat_diferencia <- mat_esqueleto - mat_esqueleto_aux
(gpos_sin_prof <- sum(!is.nan(mat_diferencia/mat_esqueleto)))
#' Si algún profesor de tiempo completo pidió alguna materia y
#' no se la dieron. Se penaliza con -10 por cada materia.
mat_info_prof <- data.frame(Profesor = param$mat_nom_prof_total[,1],
TC = param$mat_nom_prof_total[,2],
Materias_solicitadas = 0,
Materias_asignadas = 0)
for(p in 1:length(param$mat_nom_prof_total[,1])){
(prof <- mat_info_prof[p,1])
solicitudes <- mat_solicitudes_real %>% filter(Profesor == prof)
mat_info_prof[p,3] <- dim(solicitudes)[1]
asignaciones <- mat_asignacion %>% filter(Profesor == prof)
mat_info_prof[p,4] <- dim(asignaciones)[1]
}
#' Nota:
#' Se penaliza por cada materia con tope a "num_max_asig",
#' Ej. si num_max_asig = 2 y un profesor pidió 3 o más  materias
#' pero sólo le dieron 1, entonces se penaliza 1; si le dieron 2
#' no hay penalización.
pena_x_solicitud_negada <- 0
mat_prof_TC <- mat_info_prof %>% filter(TC == 1)
for(r in 1:dim(mat_prof_TC)[1]){#Recorre los renglones
if(mat_prof_TC[r,3]>0 && mat_prof_TC[r,4]<2){
num_sols <- min(mat_prof_TC[r,3],param$num_max_asig)
num_neg <- num_sols - mat_prof_TC[r,4]
pena_x_solicitud_negada <- pena_x_solicitud_negada + (10*num_neg)
}
}
pena_x_solicitud_negada##680
### CALIFICACIÓN POR GRUPO ###
#' Se pone un +5 si el profesor asignado es de TC
ind_TC <- which(mat_calif_asig_x_gpo[,3] == 1)
mat_calif_asig_x_gpo[ind_TC,5] <- 5
#' Se penaliza con -1 por cada asignación que pudo haber tenido
#' un profesor de TC y tiene un profesor de asignatura.
mat_prof_TC <- data.frame(mat_prof_TC,Materias_negadas = 0)
for(r in 1:dim(mat_prof_TC)[1]){#Recorre los renglones
(num_sols <- min(mat_prof_TC[r,3],param$num_max_asig))
mat_prof_TC[r,5] <- num_sols - mat_prof_TC[r,4]
}
TC_falta_asig <- mat_prof_TC %>% filter(Materias_negadas > 0)
materias_no_asignadas <- data.frame(Profesor = 0,TC = 0, Materia = 0,
Num_Materia = 0,Horario = 0)
for(r in 1:dim(TC_falta_asig)[1]){#Recorre renglones de "TC_falta_asig"
indices <- which(mat_solicitudes_real[,1] == TC_falta_asig[r,1])
materias_no_asignadas <- rbind(materias_no_asignadas,
mat_solicitudes_real[indices,])
}
materias_no_asignadas <- materias_no_asignadas %>% filter(Profesor != 0)
for(r in 1:dim(mat_calif_asig_x_gpo)[1]){#Recorre renglones de "mat_calif_asig_x_gpo"
materia <- mat_calif_asig_x_gpo[r,1]
hora <- mat_calif_asig_x_gpo[r,4]
mat_aux <- materias_no_asignadas %>% filter(Materia == materia) %>% filter(
Horario == hora)
mat_calif_asig_x_gpo[r,5] <- mat_calif_asig_x_gpo[r,5] - dim(mat_aux)[1]
}
#' Para tener una calificación diferente para cada grupo, sumamos
#' a cada renglón una épsilon:
for(r in 1:dim(mat_calif_asig_x_gpo)[1]){#Recorre renglones de "mat_calif_asig_x_gpo"
(num_al <- round(runif(1,0,0.1),4))
if(mat_calif_asig_x_gpo[r,5] >= 0){
mat_calif_asig_x_gpo[r,5] <- mat_calif_asig_x_gpo[r,5] + num_al
}else{
mat_calif_asig_x_gpo[r,5] <- mat_calif_asig_x_gpo[r,5] - num_al
}
}
mat_calif_asig_x_gpo <- mat_calif_asig_x_gpo[order(mat_calif_asig_x_gpo$calif),]
#' Agregamos una columna con la probabilidad acumulada de elegir cada
#' grupo.
(n_gpos <- dim(mat_calif_asig_x_gpo)[1])
mat_calif_asig_x_gpo[1,6] <- (2*1)/(n_gpos*(n_gpos+1))
for(r in 2:dim(mat_calif_asig_x_gpo)[1]){#Recorre renglones de "mat_calif_asig_x_gpo"
prob <- (2*r)/(n_gpos*(n_gpos+1))
mat_calif_asig_x_gpo[r,6] <- mat_calif_asig_x_gpo[(r-1),6] + prob
}
(calif_asignacion <- -sum(gpos_sin_prof,gpos_sin_prof,
pena_x_solicitud_negada,
-mean(mat_calif_asig_x_gpo[,5])))
lista_calif_asignacion <- list()
lista_calif_asignacion[[1]] <- mat_calif_asig_x_gpo
lista_calif_asignacion[[2]] <- calif_asignacion
cat("\nLa función califica_asignacion tardó: ",(proc.time()-ptm)[3],
" segundos\n")
return(lista_calif_asignacion)
}
# ptm <- proc.time()# Start the clock!
#Se definen las variables que se van a utilizar
tam_poblacion <- param$tam_poblacion
num_generaciones <- param$num_generaciones
prob_mutacion <- param$prob_mutacion
n_cols_mat_calif <- param$n_cols_mat_calif
matrices_calif_x_generacion <- list()
mejores_asig <- list()
vec_prob_asig <- (2*(1:tam_poblacion))/(tam_poblacion*(tam_poblacion+1))
calif_mejor_elem <- rep(0,num_generaciones)
colMain <- colorRampPalette(brewer.pal(8, "Blues"))(25)
mat_calif_generaciones <- matrix(0,nrow = tam_poblacion,
ncol = num_generaciones)
ptm <- proc.time()# Start the clock!
for(g in 1:num_generaciones){
cat("\n *** GENERACIÓN ",g," ***")
# ptm <- proc.time()# Start the clock!
if(g == 1){#Población inicial
### 1) Generar población inicial y 2) Calificar
lista_info_inicial <- poblacion_calif_iniciales(mat_esqueleto,
mat_solicitudes_real,
param)#5.22/4.82 min
mat_calif_asig <- lista_info_inicial[[1]]
poblacion <- lista_info_inicial[[2]]
### 12) Guardar una matriz con la calificación x gpo. de las
#' asignaciones (como xiii de T45)
matrices_calif_x_generacion[[g]] <- lista_info_inicial[[3]]
}else{
lista_info <- califica_ordena_asig(poblacion_nueva,param)
mat_calif_asig <- lista_info[[1]]
poblacion <- lista_info[[2]]
### 12) Guardar una matriz con la calificación x gpo. de las
#' asignaciones (como xiii de T45)
matrices_calif_x_generacion[[g]] <- lista_info[[3]]
}
### 13) Hacer heatmap de la matriz en 12)
heatmap(matrices_calif_x_generacion[[g]][,1:650],
Colv = NA, Rowv = NA,
main = paste0("Calificaciones ordenadas de generación ",g),
scale="none",col=colMain)
### 11) Guardar la mejor asignación de la generación
ind_mejor_asig <- mat_calif_asig[tam_poblacion,1]
mejores_asig[[g]] <- list(mat_calif_asig,
poblacion[[ind_mejor_asig]])
#Graficar datos
calif_mejor_elem[g] <- mat_calif_asig[tam_poblacion,2]
plot(calif_mejor_elem[1:g],main = "Calificaciones del mejor elemento",
xlab = "Generación",ylab = "Calificación")
mat_calif_generaciones[,g] <- mat_calif_asig[,2]
matplot(mat_calif_generaciones[,1:g],type = "l",
main = "Calificaciones de las asignaciones por generación",
xlab = "Asignaciones",ylab = "Calificaciones")
# ptm <- proc.time()# Start the clock!
for(n in 1:tam_poblacion){
cat("\n *** HIJO ",n," ***")
if(n == 1){poblacion_nueva <- list()}
hijo <- data.frame(Materia = 0, Profesor = 0,TC = 0,
Horario = 0)
esq_hijo <- matrix(0,nrow = length(param$Horas),
ncol = length(param$vec_nom_materias_total))
### 4) Elegir 2 padres con prob = 2i/(n*(n+1))
#' La selección es por "Rank Selection":
#' a) Elegir 2 individuos aleatoriamente
#' b) La asignación con la calificación más alta es el padre 1
#' c) Repetir a) y b) para el padre 2
#' Nota: Se toman los índices y no los números de las asignaciones
#' porque se tiene el vector de probabilidades que depende de
#' la posición en la que se encuentren las asignaciones.
ind_padres <- c(0,0)
(ind_mat_1 <- sample(x = 1:tam_poblacion,size = 2,
prob = vec_prob_asig))
ind_padres[1] <- max(ind_mat_1)
(ind_mat_2 <- sample(x = 1:tam_poblacion,size = 2,
prob = vec_prob_asig))
ind_padres[2] <- max(ind_mat_2)
padre_1 <- poblacion[[ind_padres[1]]]
padre_2 <- poblacion[[ind_padres[2]]]
while(dim(padre_1)[1]!=0 && dim(padre_2)[1]!=0){
# Repetir hasta que uno de los padres se quede sin genes.
### 5) Con prob = 0.5 se elige un padre
(ind_padre_elegido <- sample(x=1:2,size = 1))
cat("\n Se eligió al padre ",ind_padre_elegido)
if(ind_padre_elegido == 1){
padre_elegido <- padre_1
}else{
padre_elegido <- padre_2
}
### 6) Elegir un gen (grupo) del padre seleccionado con prob = 2i/(n*(n+1))
(num_genes <- dim(padre_elegido)[1])
vec_prob_genes <- (2*(1:num_genes))/(num_genes*(num_genes+1))
(ind_gen <- sample(x = 1:num_genes,
size = 1,
prob = vec_prob_genes))
(gen_elegido <- padre_elegido[ind_gen,1:4])
### 7) Mutación
(r_num_muta <- runif(1))
if(r_num_muta < prob_mutacion){
cat("\n Entra a mutación")
(gen_elegido <- elige_gen_de_solicitud(mat_solicitudes_real,
hijo,param))
}
hijo <- rbind(hijo,gen_elegido)
(num_materia_gen <- arroja_num_materia(as.character(gen_elegido[1])))
(ind_hora_gen <- which(7:21 == as.numeric(gen_elegido[4])))
esq_hijo[ind_hora_gen,num_materia_gen] <- esq_hijo[ind_hora_gen,
num_materia_gen] + 1
### 8) Ajustar información de los padres con respecto al nuevo
###gen del hijo
# (num_materia_gen <- arroja_num_materia(as.character(gen_elegido[1])))
# num_max_gpos[2,num_materia_gen] <- num_max_gpos[2,num_materia_gen] + 1
lista_padres <- ajusta_genes_padres(esq_hijo,padre_1,padre_2,
gen_elegido,mat_esqueleto)
padre_1 <- lista_padres[[1]]
padre_2 <- lista_padres[[2]]
}#Fin while()
#' Quitamos el renglón de ceros inicial
hijo <- unique(hijo)#Para evitar repeticiones en los grupos
hijo <- hijo %>% filter(Profesor != 0)
### 9) Añadir los genes restantes del otro padre al hijo
if(dim(padre_1)[1] > 0){hijo <- rbind(hijo,padre_1[,1:4])}
if(dim(padre_2)[1] > 0){hijo <- rbind(hijo,padre_2[,1:4])}
### 2) Calificar y 3) Ordenar las calificaciones del hijo
# esq_hijo <- gen_esq_hijo(hijo,param)#Grupos con profesor en el hijo
lista_hijo <- list(hijo,esq_hijo)
lista_calif_hijo <- califica_asignacion(mat_esqueleto,
mat_solicitudes_real,
lista_hijo,param)
poblacion_nueva[[n]] <- lista_calif_hijo
}#Fin for(n)
# cat("\nEl ciclo tardó: ",(proc.time()-ptm)[3]/60,
#     " minutos. Para 1 generación \n")#15min
}#Fin for(g)
cat("\nEl ciclo tardó: ",(proc.time()-ptm)[3]/60,
" minutos. Para ",num_generaciones," generaciones \n")
View(poblacion_nueva[[2]])
View(poblacion_nueva[[2]][[1]])
View(poblacion_nueva[[1]][[1]])
View(poblacion_nueva[[1]][[1]])
View(mat_esqueleto)
(ind_elim_1 <- which(padre_1[,1] == as.character(gen_elegido[1])))
(ind_elim_2 <- which(padre_2[,1] == as.character(gen_elegido[1])))
(num_materia_gen <- arroja_num_materia(as.character(gen_elegido[1])))
(ind_hora_gen <- which(7:21 == as.numeric(gen_elegido[4])))
cat("\nEl hijo tiene ",esq_hijo[ind_hora_gen,num_materia_gen],
" grupos. \nEl esqueleto tiene ",
mat_esqueleto[ind_hora_gen,num_materia_gen],"grupos.")
gen_elegido
(ind_elim_1 <- which(padre_1[,1] == as.character(gen_elegido[1])))
(ind_elim_2 <- which(padre_2[,1] == as.character(gen_elegido[1])))
#' Padre 1
(ind_prof_1 <- which(padre_1[,2] == as.character(gen_elegido[2])))
(ind_hora_1 <- which(padre_1[,4] == as.character(gen_elegido[4])))
(ind_materia_1 <- which(padre_1[,1] == as.character(gen_elegido[1])))
(ind_1 <- intersect(ind_prof_1,union(ind_hora_1,ind_materia_1)))
union(ind_1,ind_elim_1)
ind_elim_1
ind_hora_1
cat("\n Se eligió el gen: \n",as.character(gen_elegido))
cat("\n El padre 1 tiene ",dim(padre_1)[1]," genes. \n El padre 2 tiene ",
dim(padre_2)[1]," genes")
gen_elegido
gen_elegido[1] <- "Álgebra Lineal I"
gen_elegido
cat("\n Se eligió el gen: \n",as.character(gen_elegido))
cat("\n El padre 1 tiene ",dim(padre_1)[1]," genes. \n El padre 2 tiene ",
dim(padre_2)[1]," genes")
(num_materia_gen <- arroja_num_materia(as.character(gen_elegido[1])))
(ind_hora_gen <- which(7:21 == as.numeric(gen_elegido[4])))
cat("\nEl hijo tiene ",esq_hijo[ind_hora_gen,num_materia_gen],
" grupos. \nEl esqueleto tiene ",
mat_esqueleto[ind_hora_gen,num_materia_gen],"grupos.")
(ind_elim_1 <- which(padre_1[,1] == as.character(gen_elegido[1])))
(ind_elim_2 <- which(padre_2[,1] == as.character(gen_elegido[1])))
#' Padre 1
(ind_prof_1 <- which(padre_1[,2] == as.character(gen_elegido[2])))
(ind_hora_1 <- which(padre_1[,4] == as.character(gen_elegido[4])))
(ind_materia_1 <- which(padre_1[,1] == as.character(gen_elegido[1])))
(ind_1 <- intersect(ind_prof_1,union(ind_hora_1,ind_materia_1)))
intersect(ind_elim_1,ind_hora_1)
ind_1
union(ind_1,intersect(ind_elim_1,ind_hora_1))
# ajusta_genes_padres -----------------------------------------------------
#' Title ajusta_genes_padres: Función que se encarga de quitar la
#' información en los padres, del profesor en "gen_elegido" a esa hora y
#' con esa materia. Se tiene una cota para que el número de grupos del hijo
#' no supere el número de grupos de mat_esqueleto.
#'
#' @param esq_hijo: Matriz de 15 renglones (horas) y 203 columnas
#' (materias). En la entrada (i,j) se tiene el número de grupos del hijo
#' para la hora i, y la materia j.
#' @param padre_1: Asignación elegida para crear un hijo.
#' @param padre_2: Asignación elegida para crear un hijo.
#' @param gen_elegido: Vector de 4 entradas (Materia,Profesor,TC,Horario)
#' con la información del gen del padre elegido.
#' @param mat_esqueleto: Matriz de 15 renglones (horas) y 203 columnas
#' (materias). En la entrada (i,j) se tiene el número de grupos simulados
#' para la hora i, y la materia j.
#'
#' @return lista_padres: Lista con los 2 padres actualizados.
#'
#' @examples
#' lista_padres <- ajusta_genes_padres(esq_hijo,padre_1,padre_2,
#' gen_elegido,mat_esqueleto)
#'
ajusta_genes_padres <- function(esq_hijo,padre_1,padre_2,gen_elegido,
mat_esqueleto){
cat("\n Se eligió el gen: \n",as.character(gen_elegido))
cat("\n El padre 1 tiene ",dim(padre_1)[1]," genes. \n El padre 2 tiene ",
dim(padre_2)[1]," genes")
(num_materia_gen <- arroja_num_materia(as.character(gen_elegido[1])))
(ind_hora_gen <- which(7:21 == as.numeric(gen_elegido[4])))
if(esq_hijo[ind_hora_gen,num_materia_gen] >= mat_esqueleto[ind_hora_gen,
num_materia_gen]){
cat("\nEl hijo tiene ",esq_hijo[ind_hora_gen,num_materia_gen],
" grupos. \nEl esqueleto tiene ",
mat_esqueleto[ind_hora_gen,num_materia_gen],"grupos.")
(ind_elim_1 <- which(padre_1[,1] == as.character(gen_elegido[1])))
(ind_elim_2 <- which(padre_2[,1] == as.character(gen_elegido[1])))
}
#' Padre 1
(ind_prof_1 <- which(padre_1[,2] == as.character(gen_elegido[2])))
(ind_hora_1 <- which(padre_1[,4] == as.character(gen_elegido[4])))
(ind_materia_1 <- which(padre_1[,1] == as.character(gen_elegido[1])))
(ind_1 <- intersect(ind_prof_1,union(ind_hora_1,ind_materia_1)))
#' Se intersecta los índices de ind_elim_1 con los de la hora
#' porque sólo se eliminan esos grupos.
(ind_1 <- union(ind_1,intersect(ind_elim_1,ind_hora_1)))
if(length(ind_1) > 0){
padre_1 <- padre_1[-ind_1,]
cat("\n Se eliminaron del padre 1: ",length(ind_1)," entradas")
}
#' Padre 2
(ind_prof_2 <- which(padre_2[,2] == as.character(gen_elegido[2])))
(ind_hora_2 <- which(padre_2[,4] == as.character(gen_elegido[4])))
(ind_materia_2 <- which(padre_2[,1] == as.character(gen_elegido[1])))
(ind_2 <- intersect(ind_prof_2,union(ind_hora_2,ind_materia_2)))
#' Se intersecta los índices de ind_elim_2 con los de la hora
#' porque sólo se eliminan esos grupos.
(ind_2 <- union(ind_2,intersect(ind_elim_2,ind_hora_2)))
if(length(ind_2) > 0){
padre_2 <- padre_2[-ind_2,]
cat("\n Se eliminaron del padre 2: ",length(ind_2)," entradas")
}
cat("\n El padre 1 tiene ",dim(padre_1)[1]," genes. \n El padre 2 tiene ",
dim(padre_2)[1]," genes\n\n")
lista_padres <- list()
lista_padres[[1]] <- padre_1
lista_padres[[2]] <- padre_2
return(lista_padres)
}
# ptm <- proc.time()# Start the clock!
#Se definen las variables que se van a utilizar
tam_poblacion <- param$tam_poblacion
num_generaciones <- param$num_generaciones
prob_mutacion <- param$prob_mutacion
n_cols_mat_calif <- param$n_cols_mat_calif
matrices_calif_x_generacion <- list()
mejores_asig <- list()
vec_prob_asig <- (2*(1:tam_poblacion))/(tam_poblacion*(tam_poblacion+1))
calif_mejor_elem <- rep(0,num_generaciones)
colMain <- colorRampPalette(brewer.pal(8, "Blues"))(25)
mat_calif_generaciones <- matrix(0,nrow = tam_poblacion,
ncol = num_generaciones)
ptm <- proc.time()# Start the clock!
for(g in 1:num_generaciones){
cat("\n *** GENERACIÓN ",g," ***")
# ptm <- proc.time()# Start the clock!
if(g == 1){#Población inicial
### 1) Generar población inicial y 2) Calificar
lista_info_inicial <- poblacion_calif_iniciales(mat_esqueleto,
mat_solicitudes_real,
param)#5.22/4.82 min
mat_calif_asig <- lista_info_inicial[[1]]
poblacion <- lista_info_inicial[[2]]
### 12) Guardar una matriz con la calificación x gpo. de las
#' asignaciones (como xiii de T45)
matrices_calif_x_generacion[[g]] <- lista_info_inicial[[3]]
}else{
lista_info <- califica_ordena_asig(poblacion_nueva,param)
mat_calif_asig <- lista_info[[1]]
poblacion <- lista_info[[2]]
### 12) Guardar una matriz con la calificación x gpo. de las
#' asignaciones (como xiii de T45)
matrices_calif_x_generacion[[g]] <- lista_info[[3]]
}
### 13) Hacer heatmap de la matriz en 12)
heatmap(matrices_calif_x_generacion[[g]][,1:650],
Colv = NA, Rowv = NA,
main = paste0("Calificaciones ordenadas de generación ",g),
scale="none",col=colMain)
### 11) Guardar la mejor asignación de la generación
ind_mejor_asig <- mat_calif_asig[tam_poblacion,1]
mejores_asig[[g]] <- list(mat_calif_asig,
poblacion[[ind_mejor_asig]])
#Graficar datos
calif_mejor_elem[g] <- mat_calif_asig[tam_poblacion,2]
plot(calif_mejor_elem[1:g],main = "Calificaciones del mejor elemento",
xlab = "Generación",ylab = "Calificación")
mat_calif_generaciones[,g] <- mat_calif_asig[,2]
matplot(mat_calif_generaciones[,1:g],type = "l",
main = "Calificaciones de las asignaciones por generación",
xlab = "Asignaciones",ylab = "Calificaciones")
# ptm <- proc.time()# Start the clock!
for(n in 1:tam_poblacion){
cat("\n *** HIJO ",n," ***")
if(n == 1){poblacion_nueva <- list()}
hijo <- data.frame(Materia = 0, Profesor = 0,TC = 0,
Horario = 0)
esq_hijo <- matrix(0,nrow = length(param$Horas),
ncol = length(param$vec_nom_materias_total))
### 4) Elegir 2 padres con prob = 2i/(n*(n+1))
#' La selección es por "Rank Selection":
#' a) Elegir 2 individuos aleatoriamente
#' b) La asignación con la calificación más alta es el padre 1
#' c) Repetir a) y b) para el padre 2
#' Nota: Se toman los índices y no los números de las asignaciones
#' porque se tiene el vector de probabilidades que depende de
#' la posición en la que se encuentren las asignaciones.
ind_padres <- c(0,0)
(ind_mat_1 <- sample(x = 1:tam_poblacion,size = 2,
prob = vec_prob_asig))
ind_padres[1] <- max(ind_mat_1)
(ind_mat_2 <- sample(x = 1:tam_poblacion,size = 2,
prob = vec_prob_asig))
ind_padres[2] <- max(ind_mat_2)
padre_1 <- poblacion[[ind_padres[1]]]
padre_2 <- poblacion[[ind_padres[2]]]
while(dim(padre_1)[1]!=0 && dim(padre_2)[1]!=0){
# Repetir hasta que uno de los padres se quede sin genes.
### 5) Con prob = 0.5 se elige un padre
(ind_padre_elegido <- sample(x=1:2,size = 1))
cat("\n Se eligió al padre ",ind_padre_elegido)
if(ind_padre_elegido == 1){
padre_elegido <- padre_1
}else{
padre_elegido <- padre_2
}
### 6) Elegir un gen (grupo) del padre seleccionado con prob = 2i/(n*(n+1))
(num_genes <- dim(padre_elegido)[1])
vec_prob_genes <- (2*(1:num_genes))/(num_genes*(num_genes+1))
(ind_gen <- sample(x = 1:num_genes,
size = 1,
prob = vec_prob_genes))
(gen_elegido <- padre_elegido[ind_gen,1:4])
### 7) Mutación
(r_num_muta <- runif(1))
if(r_num_muta < prob_mutacion){
cat("\n Entra a mutación")
(gen_elegido <- elige_gen_de_solicitud(mat_solicitudes_real,
hijo,param))
}
hijo <- rbind(hijo,gen_elegido)
(num_materia_gen <- arroja_num_materia(as.character(gen_elegido[1])))
(ind_hora_gen <- which(7:21 == as.numeric(gen_elegido[4])))
esq_hijo[ind_hora_gen,num_materia_gen] <- esq_hijo[ind_hora_gen,
num_materia_gen] + 1
### 8) Ajustar información de los padres con respecto al nuevo
###gen del hijo
# (num_materia_gen <- arroja_num_materia(as.character(gen_elegido[1])))
# num_max_gpos[2,num_materia_gen] <- num_max_gpos[2,num_materia_gen] + 1
lista_padres <- ajusta_genes_padres(esq_hijo,padre_1,padre_2,
gen_elegido,mat_esqueleto)
padre_1 <- lista_padres[[1]]
padre_2 <- lista_padres[[2]]
}#Fin while()
#' Quitamos el renglón de ceros inicial
hijo <- unique(hijo)#Para evitar repeticiones en los grupos
hijo <- hijo %>% filter(Profesor != 0)
### 9) Añadir los genes restantes del otro padre al hijo
if(dim(padre_1)[1] > 0){hijo <- rbind(hijo,padre_1[,1:4])}
if(dim(padre_2)[1] > 0){hijo <- rbind(hijo,padre_2[,1:4])}
### 2) Calificar y 3) Ordenar las calificaciones del hijo
# esq_hijo <- gen_esq_hijo(hijo,param)#Grupos con profesor en el hijo
lista_hijo <- list(hijo,esq_hijo)
lista_calif_hijo <- califica_asignacion(mat_esqueleto,
mat_solicitudes_real,
lista_hijo,param)
poblacion_nueva[[n]] <- lista_calif_hijo
}#Fin for(n)
# cat("\nEl ciclo tardó: ",(proc.time()-ptm)[3]/60,
#     " minutos. Para 1 generación \n")#15min
}#Fin for(g)
cat("\nEl ciclo tardó: ",(proc.time()-ptm)[3]/60,
" minutos. Para ",num_generaciones," generaciones \n")
View(poblacion_nueva[[1]][[1]])
View(poblacion_nueva[[1]])
View(poblacion_nueva)
